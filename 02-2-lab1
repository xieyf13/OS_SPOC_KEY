2.1
描述符特权级DPL、当前特权级CPL和请求特权级RPL的含义是什么？在哪些寄存器中这些字段？对应的访问条件是什么？ 

符特权级DPL存储在段描述符中，规定访问该段的权限级别(Descriptor Privilege Level)，每个段的DPL固定。
当前特权级CPL是当前进程的权限级别(Current Privilege Level)，是当前正在执行的代码所在的段的特权级，存在于cs寄存器的低两位。
请求特权级RPL说明的是进程对段访问的请求权限(Request Privilege Level)，是对于段选择子而言的，每个段选择子有自己的RPL，它说明的是进程对段访问的请求权限，有点像函数参数。而且RPL对每个段来说不是固定的，两次访问同一段时的RPL可以不同。RPL可能会削弱CPL的作用，例如当前CPL=0的进程要访问一个数据段，它把段选择符中的RPL设为3，这样虽然它对该段仍然只有特权为3的访问权限。

访问条件：
访问数据段或堆栈段时，要求max {CPL, RPL} ≤ DPL。


2.2
比较不同特权级的中断切换时的堆栈变化差别；(challenge)写出一些简单的小程序（c or asm）来显示出不同特权级的的中断切换的堆栈变化情况。

使用调用门的过程实际上分为两部分，一部分是从低特权级到高特权级，通过调用门和call指令来实现；另一部分则是从高特权级到低特权级，通过ret指令来实现。

执行call前后堆栈段的变化： 
(1)根据目标代码段的DPL(即新的CPL)从TSS中选择应该切换至哪个ss和esp 
(2)从TSS中读取新的ss和esp。在这过程中如果发现ss、esp或者TSS界限错误都会导致无效TSS异常 
(3)对ss描述符进行检验，如果发生错误，同样产生#TS异常 
(4)暂时性地保存当前ss和esp的值 
(5)加载新的ss和esp 
(6)将刚刚保存起来的ss和esp的值压入新栈 
(7)从调用者堆栈中将参数复制到被调用者堆栈（新堆栈）中，复制参数的数目由调用门中Param Count一项来决定。 
(8)如果Param Count是零的话，将不会复制参数。 
(9)将当前的cs和eip压栈 
(10)加载调用门中指定的新的cs和eip，开始执行被调用者过程。

执行ret前后堆栈段的变化：
(1)检查保存的cs中的RPL以判断返回时是否要变换特权级
(2)加载被调用者堆栈上的cs和eip
(3)如果ret指令含有参数，则增加esp的值以跳过参数，然后esp将指向被保存过的调用者ss和esp。
(4)加载ss和esp,切换到调用者堆栈，被调用者的ss和esp被丢弃。
(5)如果ret指令含有参数，增加esp的值以跳过参数
(6)检查ds、es、fs、gs的值，如果其中哪一个寄存器指向的段满足DPL<CPL，那么一个空描述符会被加载到该寄存器中。
